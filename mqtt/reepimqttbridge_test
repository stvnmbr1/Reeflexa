import (
	"crypto/tls"
	mqtt "github.com/eclipse/paho.mqtt.golang"
	"log"
	"os"
)

type MQTTConfig struct {
	server   string
	subtopic string
	pubtopic string
	username string
	clientid string
	password string
	qos      int
	retained bool
}

var DefaultMQTTConfig = MQTTConfig{
	server:   "tcp://127.0.0.1:1883", // "The full URL of the MQTT server to connect to
	pubtopic:    "reef-pi-out",              // Topic to publish the messages on
	subtopic:    "reef-pi-in",              // Topic to publish the messages on
	qos:      0,                      // The QoS to send the messages at
	retained: false,                  // Are the messages sent with the retained flag
	username: "",                     // A username to authenticate to the MQTT server
	password: "",                     //Password to match username
	clientid: "reef-pi.local",
}



func NewMQTTClient(conf MQTTConfig) (*MQTTClient, error) {
	connOpts := mqtt.NewClientOptions().AddBroker(conf.server).SetClientID(conf.clientid).SetCleanSession(true)
	if conf.username != "" {
		connOpts.SetUsername(conf.username)
		if conf.password != "" {
			connOpts.SetPassword(conf.password)
		}
	}
	tlsConfig := &tls.Config{InsecureSkipVerify: true, ClientAuth: tls.NoClientCert}
	connOpts.SetTLSConfig(tlsConfig)

	client := mqtt.NewClient(connOpts)
	if token := client.Connect(); token.Wait() && token.Error() != nil {
		return nil, token.Error()
	}
	return &MQTTClient{
		config: conf,
		client: client,
	}, nil
       
       
       
       
  if token := client.Subscribe(subtopic, 0, func(client mqtt.Client, msg mqtt.Message) {
          
          if string(msg.Payload()) = "GET*" {
                   if token := client.Publish(pubtopic, byte(m.config.qos), m.config.retained, "received test get"); token.Wait() && token.Error() != nil {
                           t.Fatal(token.Error())
                   }
          }
          if string(msg.Payload()) != "mymessage" {
                   t.Fatalf("want mymessage, got %s", msg.Payload())
          }
  }); token.Wait() && token.Error() != nil {
         t.Fatal(token.Error())
  }
}
