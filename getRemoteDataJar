const GetAPITestHandler = {
  canHandle(handlerInput) {
    return (handlerInput.requestEnvelope.request.type === 'IntentRequest'
      && handlerInput.requestEnvelope.request.intent.name === 'GetAPITestIntent');
  },
  async handle(handlerInput) {
    let outputSpeech = 'No data received for Timer Overview.';

    await getRemoteDataJar('/api/timers')
      .then((response) => {
        const data = JSON.parse(response);
        outputSpeech = `There are currently ${data.length} timers setup. `;
        for (let i = 0; i < data.length; i++) {
          if (i === 0) {
            //first record
            if(data[i].enable==true){
            outputSpeech = outputSpeech + data[i].name + ' which is enabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds, '
            } else if (data[i].enable==false) {
            outputSpeech = outputSpeech + data[i].name + ' which is disabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds, '
            }
          } else if (i === data.length - 1) {
            //last record
            if(data[i].enable==true){
            outputSpeech = outputSpeech + data[i].name + ' which is enabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds. '
            } else if (data[i].enable==false) {
            outputSpeech = outputSpeech + data[i].name + ' which is disabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds. '
            }
          } else {
            //middle record(s)
            if(data[i].enable==true){
            outputSpeech = outputSpeech + ' and ' + data[i].name + ' which is enabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds, '
            } else if (data[i].enable==false) {
            outputSpeech = outputSpeech + ' and '+ data[i].name + ' which is disabled and controls ' + data[i].type + ' that runs every ' + data[i].day + ' ,rest: ' + data[i].hour + data[i].minute + data[i].second + 'for a duration of ' + data[i].equipment.duration + ' seconds, '
            }
          }
        }
      })
      .catch((err) => {
        //set an optional error message here
        //outputSpeech = err.message;
      });

    return handlerInput.responseBuilder
      .speak(outputSpeech)
      .getResponse();

  },
};



const getRemoteDataJar = function (url) {
  return new Promise((resolve, reject) => {
    var logindata = JSON.stringify({user: "reef-pi", password: "reef-pi"})
    const loginoptions = {
      host: 'externalip:port',
      path: '/auth/signin',
      method: 'POST',
      json: true,
      body: logindata
    }
    const login = http.request(loginoptions, (response) => {
      if (response.statusCode < 200 || response.statusCode > 299) {
        reject(new Error('Failed with status code: ' + response.statusCode));
      }
      const cookie = [];
      response.on('data', (chunk) => cookie.push(chunk));
      response.on('end', () => resolve(cookie.join('')));
    });
    request.on('error', (err) => reject(err))
    
    const getoptions = {
      host: 'externalip:port',
      path: url,
      method: 'GET',
      header: login.headers
    }
    const request = http.request(getoptions, url, (response) => {
      if (response.statusCode < 200 || response.statusCode > 299) {
        reject(new Error('Failed with status code: ' + response.statusCode));
      }
      const body = [];
      response.on('data', (chunk) => body.push(chunk));
      response.on('end', () => resolve(body.join('')));
    });
    request.on('error', (err) => reject(err))
  })
};
